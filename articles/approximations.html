<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Approximate Inference for Multinomial Logit Models with Random Effects • mclogit</title>
<script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Approximate Inference for Multinomial Logit Models with Random Effects">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">mclogit</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.9.15</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>The statistical models</h6></li>
    <li><a class="dropdown-item" href="../articles/conditional-logit.html">Conditional logit models</a></li>
    <li><a class="dropdown-item" href="../articles/baseline-logit.html">Baseline-category logit models</a></li>
    <li><a class="dropdown-item" href="../articles/baseline-and-conditional-logit.html">The relation between baseline logit and conditional logit models</a></li>
    <li><a class="dropdown-item" href="../articles/random-effects.html">Random effects in baseline logit models and conditional logit models</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Technical aspects of model fitting</h6></li>
    <li><a class="dropdown-item" href="../articles/fitting-mclogit.html">The IWLS algorithm used to fit conditional logit models</a></li>
    <li><a class="dropdown-item" href="../articles/approximations.html">Approximate Inference for Multinomial Logit Models with Random Effects</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/melff/mclogit/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-lightswitch" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-label="Light switch"><span class="fa fa-sun"></span></button>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="dropdown-lightswitch">
<li><button class="dropdown-item" data-bs-theme-value="light"><span class="fa fa-sun"></span> Light</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="dark"><span class="fa fa-moon"></span> Dark</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="auto"><span class="fa fa-adjust"></span> Auto</button></li>
  </ul>
</li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Approximate Inference for Multinomial Logit Models with Random Effects</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/melff/mclogit/blob/main/vignettes/approximations.Rmd" class="external-link"><code>vignettes/approximations.Rmd</code></a></small>
      <div class="d-none name"><code>approximations.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="the-problem">The problem<a class="anchor" aria-label="anchor" href="#the-problem"></a>
</h2>
<p>A crucial problem for inference about non-linear models with random
effects is that the likelihood function for such models involves
integrals for which no analytical solution exists.</p>
<p>For given values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐛</mi><annotation encoding="application/x-tex">\boldsymbol{b}</annotation></semantics></math>
of the random effects the likelihood function of a conditional logit
model (and therefore also of a baseline-logit model) can be written in
the form</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ℒ</mi><mtext mathvariant="normal">cpl</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>ℓ</mo><mtext mathvariant="normal">cpl</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>ℓ</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo stretchy="false" form="prefix">|</mo><mi>𝐛</mi><mo>;</mo><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>ln</mo><mo>det</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝚺</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>𝐛</mi><mi>′</mi><msup><mi>𝚺</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathcal{L}_{\text{cpl}}(\boldsymbol{y},\boldsymbol{b})
=
\exp\left(\ell_{\text{cpl}}(\boldsymbol{y},\boldsymbol{b})\right)
=\exp
\left(
\ell(\boldsymbol{y}|\boldsymbol{b};\boldsymbol{\alpha})
-\frac12\ln\det(\boldsymbol{\Sigma})
-\frac12\boldsymbol{b}'\boldsymbol{\Sigma}^{-1}\boldsymbol{b}
\right)
</annotation></semantics></math></p>
<p>However, this “complete data” likelihood function cannot be used for
inference, because it depends on the unobserved random effects. To
arrive at a likelihood function that depends only on observed data, one
needs to used the following integrated likelihood function:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ℒ</mi><mtext mathvariant="normal">obs</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>∫</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>ℓ</mo><mtext mathvariant="normal">cpl</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>∂</mi><mi>𝐛</mi><mo>=</mo><mo>∫</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>ℓ</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo stretchy="false" form="prefix">|</mo><mi>𝐛</mi><mo>;</mo><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>ln</mo><mo>det</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝚺</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>𝐛</mi><mi>′</mi><msup><mi>𝚺</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>∂</mi><mi>𝐛</mi></mrow><annotation encoding="application/x-tex">
\mathcal{L}_{\text{obs}}(\boldsymbol{y})
=
\int
\exp\left(\ell_{\text{cpl}}(\boldsymbol{y},\boldsymbol{b})\right)
\partial \boldsymbol{b}
=
\int
\exp
\left(
\ell(\boldsymbol{y}|\boldsymbol{b};\boldsymbol{\alpha})
-\frac12\ln\det(\boldsymbol{\Sigma})
-\frac12\boldsymbol{b}'\boldsymbol{\Sigma}^{-1}\boldsymbol{b}
\right)
\partial \boldsymbol{b}
</annotation></semantics></math></p>
<p>In general, this integral cannot be “solved”, i.e. eliminated from
the formula by analytic means (it is “analytically untractable”).
Instead, one will compute it either using numeric techniques (e.g. using
numerical quadrature) or approximate it using analytical techniques.
Unless there is only a single level of random effects numerical
quadrature can become computationally be demanding, that is, the
computation of the (log-)likelihood function and its derivatives can
take a lot of time even on modern, state-of-the-art computer hardware.
Yet approximations based on analytical techniques hand may lead to
biased estimates in particular in samples where the number of
observations relative to the number of random offects is small, but at
least they are much easier to compute and sometimes making inference
possible after all.</p>
<p>The package “mclogit” supports to kinds of analytical approximations,
the Laplace approximation and what one may call the Solomon-Cox
appoximation. Both approximations are based on a quadratic expansion of
the integrand so that the thus modified integral does have a closed-form
solution, i.e. is analytically tractable.</p>
</div>
<div class="section level2">
<h2 id="the-laplace-approximation-and-pql">The Laplace approximation and PQL<a class="anchor" aria-label="anchor" href="#the-laplace-approximation-and-pql"></a>
</h2>
<div class="section level3">
<h3 id="laplace-approximation">Laplace approximation<a class="anchor" aria-label="anchor" href="#laplace-approximation"></a>
</h3>
<p>The (first-order) Laplace approximation is based on the quadratic
expansion the logarithm of the integrand, the complete-data
log-likelihood</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>ℓ</mo><mtext mathvariant="normal">cpl</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≈</mo><mo>ℓ</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo stretchy="false" form="prefix">|</mo><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><mo>;</mo><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐛</mi><mo>−</mo><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi><mover><mi>𝐇</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐛</mi><mo>−</mo><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>ln</mo><mo>det</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝚺</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐛</mi><mo>−</mo><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi><msup><mi>𝚺</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐛</mi><mo>−</mo><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\ell_{\text{cpl}}(\boldsymbol{y},\boldsymbol{b})\approx
\ell(\boldsymbol{y}|\tilde{\boldsymbol{b}};\boldsymbol{\alpha})
-
\frac12
(\boldsymbol{b}-\tilde{\boldsymbol{b}})'
\tilde{\boldsymbol{H}}
(\boldsymbol{b}-\tilde{\boldsymbol{b}})
-\frac12\ln\det(\boldsymbol{\Sigma})
-\frac12(\boldsymbol{b}-\tilde{\boldsymbol{b}})'\boldsymbol{\Sigma}^{-1}(\boldsymbol{b}-\tilde{\boldsymbol{b}})
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\tilde{\boldsymbol{b}}</annotation></semantics></math>
is the solution to</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><msub><mo>ℓ</mo><mtext mathvariant="normal">cpl</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>∂</mi><mi>𝐛</mi></mrow></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">
\frac{\partial\ell_{\text{cpl}}(\boldsymbol{y},\boldsymbol{b})}{\partial\boldsymbol{b}}
= 0
</annotation></semantics></math></p>
<p>and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝐇</mi><mo accent="true">̃</mo></mover><mo>=</mo><mi>𝐇</mi><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\tilde{\boldsymbol{H}}=\boldsymbol{H}(\tilde{\boldsymbol{b}})</annotation></semantics></math>
is the value of the negative Hessian with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐛</mi><annotation encoding="application/x-tex">\boldsymbol{b}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐇</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>−</mo><mfrac><mrow><msup><mi>∂</mi><mn>2</mn></msup><mo>ℓ</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo stretchy="false" form="prefix">|</mo><mi>𝐛</mi><mo>;</mo><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>∂</mi><mi>𝐛</mi><mi>∂</mi><mi>𝐛</mi><mi>′</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\boldsymbol{H}(\boldsymbol{b})=-\frac{\partial^2\ell(\boldsymbol{y}|\boldsymbol{b};\boldsymbol{\alpha})}{\partial\boldsymbol{b}\partial\boldsymbol{b}'}
</annotation></semantics></math></p>
<p>for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐛</mi><mo>=</mo><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover></mrow><annotation encoding="application/x-tex">\boldsymbol{b}=\tilde{\boldsymbol{b}}</annotation></semantics></math>.</p>
<p>Since this quadratic expansion—let us call it
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>ℓ</mo><mtext mathvariant="normal">Lapl</mtext><mo>*</mo></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\ell^*_{\text{Lapl}}(\boldsymbol{y},\boldsymbol{b})</annotation></semantics></math>—is
a (multivariate) quadratic function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐛</mi><annotation encoding="application/x-tex">\boldsymbol{b}</annotation></semantics></math>,
the integral of its exponential does have a closed-form solution (the
relevant formula can be found in <span class="citation">Harville
(1997)</span>).</p>
<p>For purposes of estimation, the resulting approximate log-likelihood
is more useful:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>ℓ</mo><mtext mathvariant="normal">Lapl</mtext><mo>*</mo></msubsup><mo>=</mo><mo>ln</mo><mo>∫</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>ℓ</mo><mtext mathvariant="normal">Lapl</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>∂</mi><mi>𝐛</mi><mo>=</mo><mo>ℓ</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo stretchy="false" form="prefix">|</mo><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><mo>;</mo><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><mi>′</mi><msup><mi>𝚺</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>ln</mo><mo>det</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝚺</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>ln</mo><mo>det</mo><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>𝐇</mi><mo accent="true">̃</mo></mover><mo>+</mo><msup><mi>𝚺</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\ell^*_{\text{Lapl}}
=
\ln\int \exp(\ell_{\text{Lapl}}(\boldsymbol{y},\boldsymbol{b})) \partial\boldsymbol{b}
=
\ell(\boldsymbol{y}|\tilde{\boldsymbol{b}};\boldsymbol{\alpha})
-
\frac12\tilde{\boldsymbol{b}}'\boldsymbol{\Sigma}^{-1}\tilde{\boldsymbol{b}}
-
\frac12\ln\det(\boldsymbol{\Sigma})
-
\frac12\ln\det\left(\tilde{\boldsymbol{H}}+\boldsymbol{\Sigma}^{-1}\right).
</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="penalized-quasi-likelihood-pql">Penalized quasi-likelihood (PQL)<a class="anchor" aria-label="anchor" href="#penalized-quasi-likelihood-pql"></a>
</h3>
<p>If one disregards the dependence of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝐇</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\tilde{\boldsymbol{H}}</annotation></semantics></math>
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛂</mi><annotation encoding="application/x-tex">\boldsymbol{\alpha}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐛</mi><annotation encoding="application/x-tex">\boldsymbol{b}</annotation></semantics></math>,
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\tilde{\boldsymbol{b}}</annotation></semantics></math>
maximizes not only
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>ℓ</mo><mtext mathvariant="normal">cpl</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\ell_{\text{cpl}}(\boldsymbol{y},\boldsymbol{b})</annotation></semantics></math>
but also
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mo>ℓ</mo><mtext mathvariant="normal">Lapl</mtext><mo>*</mo></msubsup><annotation encoding="application/x-tex">\ell^*_{\text{Lapl}}</annotation></semantics></math>.
This motivates the following IWLS/Fisher scoring equations for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛂</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\alpha}}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\tilde{\boldsymbol{b}}</annotation></semantics></math>
(see <span class="citation">Breslow and Clayton (1993)</span> and <a href="fitting-mclogit.html">this page</a>):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>𝐗</mi><mi>′</mi><mi>𝐖</mi><mi>𝐗</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>𝐗</mi><mi>′</mi><mi>𝐖</mi><mi>𝐙</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>𝐙</mi><mi>′</mi><mi>𝐖</mi><mi>𝐗</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>𝐙</mi><mi>′</mi><mi>𝐖</mi><mi>𝐙</mi><mo>+</mo><msup><mi>𝚺</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mover><mi>𝛂</mi><mo accent="true">̂</mo></mover></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>𝐗</mi><mi>′</mi><mi>𝐖</mi><msup><mi>𝐲</mi><mo>*</mo></msup></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>𝐙</mi><mi>′</mi><mi>𝐖</mi><msup><mi>𝐲</mi><mo>*</mo></msup></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\begin{bmatrix}
\boldsymbol{X}'\boldsymbol{W}\boldsymbol{X} &amp; \boldsymbol{X}'\boldsymbol{W}\boldsymbol{Z} \\
\boldsymbol{Z}'\boldsymbol{W}\boldsymbol{X} &amp; \boldsymbol{Z}'\boldsymbol{W}\boldsymbol{Z} + \boldsymbol{\Sigma}^{-1}\\
\end{bmatrix}
\begin{bmatrix}
 \hat{\boldsymbol{\alpha}}\\
 \tilde{\boldsymbol{b}}\\
\end{bmatrix}
 =
\begin{bmatrix}
\boldsymbol{X}'\boldsymbol{W}\boldsymbol{y}^*\\
\boldsymbol{Z}'\boldsymbol{W}\boldsymbol{y}^*
\end{bmatrix}
\end{aligned}
</annotation></semantics></math></p>
<p>where</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐲</mi><mo>*</mo></msup><mo>=</mo><mi>𝐗</mi><mi>𝛂</mi><mo>+</mo><mi>𝐙</mi><mi>𝐛</mi><mo>+</mo><msup><mi>𝐖</mi><mo>−</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>−</mo><mi>𝛑</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\boldsymbol{y}^* =  \boldsymbol{X}\boldsymbol{\alpha} +
\boldsymbol{Z}\boldsymbol{b} +
\boldsymbol{W}^{-}(\boldsymbol{y}-\boldsymbol{\pi})
</annotation></semantics></math></p>
<p>is the IWLS “working dependend variable” with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛂</mi><annotation encoding="application/x-tex">\boldsymbol{\alpha}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐛</mi><annotation encoding="application/x-tex">\boldsymbol{b}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\boldsymbol{W}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛑</mi><annotation encoding="application/x-tex">\boldsymbol{\pi}</annotation></semantics></math>
computed in an earlier iteration.</p>
<p>Substitutions lead to the equations:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐗</mi><msup><mi>𝐕</mi><mo>−</mo></msup><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow><mover><mi>𝛂</mi><mo accent="true">̂</mo></mover><mo>=</mo><mi>𝐗</mi><msup><mi>𝐕</mi><mo>−</mo></msup><msup><mi>𝐲</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">
(\boldsymbol{X}\boldsymbol{V}^-\boldsymbol{X})\hat{\boldsymbol{\alpha}} =
\boldsymbol{X}\boldsymbol{V}^-\boldsymbol{y}^*
</annotation></semantics></math></p>
<p>and</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐙</mi><mi>′</mi><mi>𝐖</mi><mi>𝐙</mi><mo>+</mo><msup><mi>𝚺</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>𝐛</mi><mo>=</mo><mi>𝐙</mi><mi>′</mi><mi>𝐖</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐲</mi><mo>*</mo></msup><mo>−</mo><mi>𝐗</mi><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
(\boldsymbol{Z}'\boldsymbol{W}\boldsymbol{Z} +
\boldsymbol{\Sigma}^{-1})\boldsymbol{b} =
\boldsymbol{Z}'\boldsymbol{W}(\boldsymbol{y}^*-\boldsymbol{X}\boldsymbol{\alpha})
</annotation></semantics></math></p>
<p>which can be solved to compute
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛂</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\alpha}}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\tilde{\boldsymbol{b}}</annotation></semantics></math>
(for given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝚺</mi><annotation encoding="application/x-tex">\boldsymbol{\Sigma}</annotation></semantics></math>)</p>
<p>Here</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐕</mi><mo>=</mo><msup><mi>𝐖</mi><mo>−</mo></msup><mo>+</mo><mi>𝐙</mi><mi>𝚺</mi><mi>𝐙</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">
\boldsymbol{V} =
\boldsymbol{W}^-+\boldsymbol{Z}\boldsymbol{\Sigma}\boldsymbol{Z}'
</annotation></semantics></math></p>
<p>and</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐕</mi><mo>−</mo></msup><mo>=</mo><mi>𝐖</mi><mo>−</mo><mi>𝐖</mi><mi>𝐙</mi><mi>′</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐙</mi><mi>′</mi><mi>𝐖</mi><mi>𝐙</mi><mo>+</mo><msup><mi>𝚺</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>𝐙</mi><mi>𝐖</mi></mrow><annotation encoding="application/x-tex">
\boldsymbol{V}^- = \boldsymbol{W}-
\boldsymbol{W}\boldsymbol{Z}'\left(\boldsymbol{Z}'\boldsymbol{W}\boldsymbol{Z}+\boldsymbol{\Sigma}^{-1}\right)^{-1}\boldsymbol{Z}\boldsymbol{W}
</annotation></semantics></math></p>
<p>Following <span class="citation">Breslow and Clayton (1993)</span>
the variance parameters in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝚺</mi><annotation encoding="application/x-tex">\boldsymbol{\Sigma}</annotation></semantics></math>
are estimated by minimizing</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub><mo>=</mo><mo>det</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐕</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐲</mi><mo>*</mo></msup><mo>−</mo><mi>𝐗</mi><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>𝐕</mi><mo>−</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐲</mi><mo>*</mo></msup><mo>−</mo><mi>𝐗</mi><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
q_1 =
\det(\boldsymbol{V})+(\boldsymbol{y}^*-\boldsymbol{X}\boldsymbol{\alpha})\boldsymbol{V}^-(\boldsymbol{y}^*-\boldsymbol{X}\boldsymbol{\alpha})
</annotation></semantics></math></p>
<p>or the “REML” variant:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>2</mn></msub><mo>=</mo><mo>det</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐕</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐲</mi><mo>*</mo></msup><mo>−</mo><mi>𝐗</mi><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>𝐕</mi><mo>−</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐲</mi><mo>*</mo></msup><mo>−</mo><mi>𝐗</mi><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mo>det</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐗</mi><mi>′</mi><msup><mi>𝐕</mi><mo>−</mo></msup><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
q_2 =
\det(\boldsymbol{V})+(\boldsymbol{y}^*-\boldsymbol{X}\boldsymbol{\alpha})\boldsymbol{V}^-(\boldsymbol{y}^*-\boldsymbol{X}\boldsymbol{\alpha})+\det(\boldsymbol{X}'\boldsymbol{V}^{-}\boldsymbol{X})
</annotation></semantics></math></p>
<p>This motivates the following algorithm, which is strongly inspired by
the <code><a href="https://rdrr.io/pkg/MASS/man/glmmPQL.html" class="external-link">glmmPQL()</a></code> function in Brian Ripley’s <em>R</em> package
<a href="https://cran.r-project.org/package=MASS" class="external-link">MASS</a> <span class="citation">(Venables and Ripley 2002)</span>:</p>
<ol style="list-style-type: decimal">
<li>Create some suitable starting values for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛑</mi><annotation encoding="application/x-tex">\boldsymbol{\pi}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\boldsymbol{W}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐲</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\boldsymbol{y}^*</annotation></semantics></math>
</li>
<li>Construct the “working dependent variable”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐲</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\boldsymbol{y}^*</annotation></semantics></math>
</li>
<li>Minimize
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>1</mn></msub><annotation encoding="application/x-tex">q_1</annotation></semantics></math>
(quasi-ML) or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>2</mn></msub><annotation encoding="application/x-tex">q_2</annotation></semantics></math>
(quasi-REML) iteratively (inner loop), to obtain an estimate of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝚺</mi><annotation encoding="application/x-tex">\boldsymbol{\Sigma}</annotation></semantics></math>
</li>
<li>Obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>t</mi><mi>𝛂</mi></mrow><annotation encoding="application/x-tex">hat{\boldsymbol{\alpha}}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\tilde{\boldsymbol{b}}</annotation></semantics></math>
based on the current estimate of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝚺</mi><annotation encoding="application/x-tex">\boldsymbol{\Sigma}</annotation></semantics></math>
</li>
<li>Compute updated
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝛈</mi><mo>=</mo><mi>𝐗</mi><mi>𝛂</mi><mo>+</mo><mi>𝐙</mi><mi>𝐛</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{\eta}=\boldsymbol{X}\boldsymbol{\alpha} +
\boldsymbol{Z}\boldsymbol{b}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛑</mi><annotation encoding="application/x-tex">\boldsymbol{\pi}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\boldsymbol{W}</annotation></semantics></math>.</li>
<li>If the change in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛈</mi><annotation encoding="application/x-tex">\boldsymbol{\eta}</annotation></semantics></math>
is smaller than a given tolerance criterion stop the algorighm and
declare it as converged. Otherwise go back to step 2 with the updated
values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛂</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\alpha}}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝐛</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\tilde{\boldsymbol{b}}</annotation></semantics></math>.</li>
</ol>
<p>This algorithm is a modification of the <a href="fitting-mclogit.html">IWLS</a> algorithm used to fit conditional
logit models without random effects. Instead of just solving a linear
requatoin in step 3, it estimates a weighted linear mixed-effects model.
In contrast to <code><a href="https://rdrr.io/pkg/MASS/man/glmmPQL.html" class="external-link">glmmPQL()</a></code> it does not use the
<code>lme()</code> function from package <a href="https://cran.r-project.org/package=nlme" class="external-link">nlme</a> <span class="citation">(Pinheiro and Bates 2000)</span> for this, because the
weighting matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\boldsymbol{W}</annotation></semantics></math>
is non-diagonal. Instead,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>1</mn></msub><annotation encoding="application/x-tex">q_1</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>2</mn></msub><annotation encoding="application/x-tex">q_2</annotation></semantics></math>
are minimized using the function <code>nlminb</code> from the standard
<em>R</em> package “stats” or some other optimizer chosen by the
user.</p>
</div>
</div>
<div class="section level2">
<h2 id="the-solomon-cox-approximation-and-mql">The Solomon-Cox approximation and MQL<a class="anchor" aria-label="anchor" href="#the-solomon-cox-approximation-and-mql"></a>
</h2>
<div class="section level3">
<h3 id="the-solomon-cox-approximation">The Solomon-Cox approximation<a class="anchor" aria-label="anchor" href="#the-solomon-cox-approximation"></a>
</h3>
<p>The (first-order) Solomon approximation <span class="citation">(Solomon and Cox 1992)</span> is based on the quadratic
expansion the integrand</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>ℓ</mo><mtext mathvariant="normal">cpl</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≈</mo><mo>ℓ</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo stretchy="false" form="prefix">|</mo><mn>𝟎</mn><mo>;</mo><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>𝐠</mi><mn>0</mn></msub><mi>′</mi><mi>𝐛</mi><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>𝐛</mi><mi>′</mi><msub><mi>𝐇</mi><mn>0</mn></msub><mi>𝐛</mi><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>ln</mo><mo>det</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝚺</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>𝐛</mi><mi>′</mi><msup><mi>𝚺</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>𝐛</mi></mrow><annotation encoding="application/x-tex">
\ell_{\text{cpl}}(\boldsymbol{y},\boldsymbol{b})\approx
\ell(\boldsymbol{y}|\boldsymbol{0};\boldsymbol{\alpha})
+
\boldsymbol{g}_0'
\boldsymbol{b}
-
\frac12
\boldsymbol{b}'
\boldsymbol{H}_0
\boldsymbol{b}
-\frac12\ln\det(\boldsymbol{\Sigma})
-\frac12\boldsymbol{b}'\boldsymbol{\Sigma}^{-1}\boldsymbol{b}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐠</mi><mi>_</mi><mn>0</mn><mo>=</mo><mi>𝐠</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>𝟎</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{g}\_0=\boldsymbol{g}(\boldsymbol{0})</annotation></semantics></math>
is the gradient of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>ℓ</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo stretchy="false" form="postfix">∥</mo><mi>𝐛</mi><mo>;</mo><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\ell(\boldsymbol{y}\|\boldsymbol{b};\boldsymbol{\alpha})</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐠</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>−</mo><mfrac><mrow><mi>∂</mi><mo>ℓ</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo stretchy="false" form="prefix">|</mo><mi>𝐛</mi><mo>;</mo><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>∂</mi><mi>𝐛</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\boldsymbol{g}(\boldsymbol{b})=-\frac{\partial\ell(\boldsymbol{y}|\boldsymbol{b};\boldsymbol{\alpha})}{\partial\boldsymbol{b}}
</annotation></semantics></math></p>
<p>at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐛</mi><mo>=</mo><mn>𝟎</mn></mrow><annotation encoding="application/x-tex">\boldsymbol{b}=\boldsymbol{0}</annotation></semantics></math>,
while
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐇</mi><mi>_</mi><mn>0</mn><mo>=</mo><mi>𝐇</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>𝟎</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{H}\_0=\boldsymbol{H}(\boldsymbol{0})</annotation></semantics></math>
is the negative Hessian at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐛</mi><mo>=</mo><mn>𝟎</mn></mrow><annotation encoding="application/x-tex">\boldsymbol{b}=\boldsymbol{0}</annotation></semantics></math>.</p>
<p>Like before, the integral of the exponential this quadratic expansion
(which we refer to as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>ℓ</mo><mtext mathvariant="normal">SC</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\ell_{\text{SC}}(\boldsymbol{y},\boldsymbol{b})</annotation></semantics></math>)
has a closed-form solution, as does its logarithm, which is:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>ln</mo><mo>∫</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>ℓ</mo><mtext mathvariant="normal">SC</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>,</mo><mi>𝐛</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>∂</mi><mi>𝐛</mi><mo>=</mo><mo>ℓ</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo stretchy="false" form="prefix">|</mo><mn>𝟎</mn><mo>;</mo><mi>𝛂</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msub><mi>𝐠</mi><mn>0</mn></msub><mi>′</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐇</mi><mn>0</mn></msub><mo>+</mo><msup><mi>𝚺</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>𝐠</mi><mn>0</mn></msub><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>ln</mo><mo>det</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝚺</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>ln</mo><mo>det</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐇</mi><mn>0</mn></msub><mo>+</mo><msup><mi>𝚺</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\ln\int \exp(\ell_{\text{SC}}(\boldsymbol{y},\boldsymbol{b})) \partial\boldsymbol{b}
=
\ell(\boldsymbol{y}|\boldsymbol{0};\boldsymbol{\alpha})
-
\frac12\boldsymbol{g}_0'\left(\boldsymbol{H}_0+\boldsymbol{\Sigma}^{-1}\right)^{-1}\boldsymbol{g}_0
-
\frac12\ln\det(\boldsymbol{\Sigma})
-
\frac12\ln\det\left(\boldsymbol{H}_0+\boldsymbol{\Sigma}^{-1}\right).
</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="marginal-quasi-likelhood-mql">Marginal quasi-likelhood (MQL)<a class="anchor" aria-label="anchor" href="#marginal-quasi-likelhood-mql"></a>
</h3>
<p>The resulting estimation technique is very similar to PQL <span class="citation">(again, see Breslow and Clayton 1993 for a
discussion)</span>. The only difference is the construction of the
“working dependent” variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐲</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\boldsymbol{y}^*</annotation></semantics></math>.
With PQL it is constructed as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐲</mi><mo>*</mo></msup><mo>=</mo><mi>𝐗</mi><mi>𝛂</mi><mo>+</mo><mi>𝐙</mi><mi>𝐛</mi><mo>+</mo><msup><mi>𝐖</mi><mo>−</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>−</mo><mi>𝛑</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{y}^* =
\boldsymbol{X}\boldsymbol{\alpha} + \boldsymbol{Z}\boldsymbol{b} +
\boldsymbol{W}^{-}(\boldsymbol{y}-\boldsymbol{\pi})</annotation></semantics></math>
while the MQL working dependent variable is just</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐲</mi><mo>*</mo></msup><mo>=</mo><mi>𝐗</mi><mi>𝛂</mi><mo>+</mo><msup><mi>𝐖</mi><mo>−</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo>−</mo><mi>𝛑</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\boldsymbol{y}^* =  \boldsymbol{X}\boldsymbol{\alpha} +
\boldsymbol{W}^{-}(\boldsymbol{y}-\boldsymbol{\pi})
</annotation></semantics></math></p>
<p>so that the algorithm has the following steps:</p>
<ol style="list-style-type: decimal">
<li>Create some suitable starting values for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛑</mi><annotation encoding="application/x-tex">\boldsymbol{\pi}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\boldsymbol{W}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐲</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\boldsymbol{y}^*</annotation></semantics></math>
</li>
<li>Construct the “working dependent variable”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐲</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\boldsymbol{y}^*</annotation></semantics></math>
</li>
<li>Minimize
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>1</mn></msub><annotation encoding="application/x-tex">q_1</annotation></semantics></math>
(quasi-ML) or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>2</mn></msub><annotation encoding="application/x-tex">q_2</annotation></semantics></math>
(quasi-REML) iteratively (inner loop), to obtain an estimate of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝚺</mi><annotation encoding="application/x-tex">\boldsymbol{\Sigma}</annotation></semantics></math>
</li>
<li>Obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛂</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\alpha}}</annotation></semantics></math>
based on the current estimate of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝚺</mi><annotation encoding="application/x-tex">\boldsymbol{\Sigma}</annotation></semantics></math>
</li>
<li>Compute updated
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝛈</mi><mo>=</mo><mi>𝐗</mi><mi>𝛂</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{\eta}=\boldsymbol{X}\boldsymbol{\alpha}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛑</mi><annotation encoding="application/x-tex">\boldsymbol{\pi}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\boldsymbol{W}</annotation></semantics></math>.</li>
<li>If the change in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛈</mi><annotation encoding="application/x-tex">\boldsymbol{\eta}</annotation></semantics></math>
is smaller than a given tolerance criterion stop the algorighm and
declare it as converged. Otherwise go back to step 2 with the updated
values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛂</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\alpha}}</annotation></semantics></math>.</li>
</ol>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-breslow.clayton:approximate.inference.glmm" class="csl-entry">
Breslow, Norman E., and David G. Clayton. 1993. <span>“Approximate
Inference in Generalized Linear Mixed Models.”</span> <em>Journal of the
American Statistical Association</em> 88 (421): 9–25.
</div>
<div id="ref-harville:matrix.algebra" class="csl-entry">
Harville, David A. 1997. <em>Matrix Algebra from a Statistician’s
Perspective</em>. New York: Springer.
</div>
<div id="ref-nlme-book" class="csl-entry">
Pinheiro, José C., and Douglas M. Bates. 2000. <em>Mixed-Effects Models
in s and s-PLUS</em>. New York: Springer. <a href="https://doi.org/10.1007/b98882" class="external-link">https://doi.org/10.1007/b98882</a>.
</div>
<div id="ref-Solomon.Cox:1992" class="csl-entry">
Solomon, P. J., and D. R. Cox. 1992. <span>“Nonlinear Component of
Variance Models.”</span> <em>Biometrika</em> 79 (1): 1–11. <a href="https://doi.org/10.1093/biomet/79.1.1" class="external-link">https://doi.org/10.1093/biomet/79.1.1</a>.
</div>
<div id="ref-MASS" class="csl-entry">
Venables, W. N., and B. D. Ripley. 2002. <em>Modern Applied Statistics
with s</em>. Fourth. New York: Springer. <a href="https://www.stats.ox.ac.uk/pub/MASS4/" class="external-link">https://www.stats.ox.ac.uk/pub/MASS4/</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Martin Elff.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
